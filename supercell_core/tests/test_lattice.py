import os
import numpy as np

from io import StringIO
from unittest.mock import patch

import supercell_core as sc

from .with_atoms import TestCaseWithAtoms
from ..errors import *


class TestLattice(TestCaseWithAtoms):
    """
    Test Lattice object
    """

    def test_vectors_good(self) -> None:
        """
        Tests methods: set_vectors, and vectors
        (cases where it succeeds)
        """
        lay = sc.lattice()

        # Testing default values
        self.assertEqual(lay.vectors(), [[1, 0, 0], [0, 1, 0], [0, 0, 1]])

        # Setting two 2D elementary cell vectors, omitting z axis as irrelevant
        lay.set_vectors([2, 3], [1, 4])
        self.assertEqual(lay.vectors(), [[2, 3, 0], [1, 4, 0], [0, 0, 1]])

        # Set two 3D elementary cell vectors while omitting the 3rd one is
        # nonsensical, unless you give '0' as z-component of these vectors
        lay.set_vectors([2, 3, 0], [1, 5, 0])
        self.assertEqual(lay.vectors(), [[2, 3, 0], [1, 5, 0], [0, 0, 1]])

        # When z-component is non '0' but the 3rd vector is left default,
        # (which means it's unclear whether 'z' direction is important for
        # the user) a warning should be issued
        with self.assertWarns(UserWarning, msg=Warning.ZComponentWhenNoZVector):
            lay.set_vectors([2, 3, 0], [1, 5, 0.2])
            self.assertEqual(lay.vectors(), [[2, 3, 0], [1, 5, 0.2], [0, 0, 1]])

        # Set three 3D vectors
        lay.set_vectors([2, 3, 0], [1, 6, 1], [7, 8, 9])
        self.assertEqual(lay.vectors(), [[2, 3, 0], [1, 6, 1], [7, 8, 9]])

        # Change only part of the vector – are you sure z-component is what you
        # think it is?
        lay = sc.lattice()
        lay.set_vectors([1, 0, 1], [0, 1, 1], [0, 0, 1])
        with self.assertWarns(UserWarning, msg=Warning.ReassigningPartOfVector):
            lay.set_vectors([2, 0], [0, 3])

    def test_vectors_bad(self) -> None:
        """
        Tests methods: set_vectors, and vectors
        (cases where they should fail)
        """
        lay = sc.lattice()

        # Test bad type of values passed to the function
        with self.assertRaises(TypeError):
            # Too few arguments – less than two
            lay.set_vectors([1, 2])

            # Too many arguments – more than three
            lay.set_vectors([1, 2, 0], [3, 4, 0], [5, 6, 7], [8, 9, 0])

            # Too short vectors
            lay.set_vectors([1], [5])

            # Too long vectors
            lay.set_vectors([1, 2, 3, 4], [5, 6, 7, 8])

            # Mismatched vectors length
            lay.set_vectors([1, 2], [1, 2, 3])

            # Wrong type
            lay.set_vectors([1, 2, 3], ["5", "6", "7"])

            # Any arguments passed to vectors
            lay.vectors("whatever")

        # Test incorrect data passed to function
        with self.assertRaises(LinearDependenceError):
            # Two linearly dependent vectors
            lay.set_vectors([1, 2], [2, 4])

            # One vector is linear combination of the second and the default
            # third vector ([0, 0, 1])
            lay.set_vectors([0, 1, 1], [0, 1, 0])

    def test_add_atoms_good(self) -> None:
        """
        Tests methods: add_atom, add_atoms, and atoms
        """
        lay = sc.lattice()

        # Test default (no atoms in an elementary cell)
        self.assertEqual(lay.atoms(), [])

        # Test add_atom Helium (default unit: angstrom)
        he = ("He", (0.1, 0.2, 0.3))
        lay.add_atom(*he)
        self.assertAtomsEqual(lay.atoms()[0], he)

        # Test add_atoms: Hydrogen and Lithium
        # Retaining element order is expected
        h, li = ("H", np.array([0, 0, 0])),\
                ("Li", np.array([0.9, 0.9, 0.9]), (0, 1, 2))
        lay.add_atoms([h, li])
        for a1, a2 in zip(lay.atoms(), [he, h, li]):
            self.assertAtomsEqual(a1, a2)

        # Add atom using 2D position vector
        be = ("Be", (0.5, 0.5), (0, 0, 1))
        lay.add_atom(*be)
        self.assertAtomsEqual(lay.atoms()[-1],
                              ("Be", np.array([0.5, 0.5, 0]), (0, 0, 1)))

        # When atom is outside the elementary cell, a warning should be logged
        with self.assertWarns(UserWarning, msg=Warning.AtomOutsideElementaryCell):
            lay.add_atom("C", (2, 0, 0))

        # Element symbol not in the periodic table
        with self.assertWarns(UserWarning, msg=Warning.UnknownChemicalElement):
            lay.add_atom("Helium", (1, 0, 0))  # should be: "He"

        # Add atom using crystal units
        lay = sc.lattice()
        lay.set_vectors([2, 0, 0], [2, 2, 0], [0, 0, 3])
        lay.add_atom("Na", (0.5, 0.5, 0.5), unit=sc.Unit.Crystal)
        self.assertAtomsEqual(lay.atoms()[0], ("Na", (2, 1, 1.5)))

        # Change lattice vectors after adding atoms
        lay.set_vectors([4, 0, 0], [4, 4, 0], [0, 0, 6],
                        atoms_behaviour=sc.Unit.Crystal)
        self.assertAtomsEqual(lay.atoms()[0], ("Na", (4, 2, 3)))

        lay.set_vectors([8, 0, 0], [8, 8, 0], [0, 0, 12],
                        atoms_behaviour=sc.Unit.Angstrom)
        self.assertAtomsEqual(lay.atoms()[0], ("Na", (4, 2, 3)))

        # List atoms using CRYSTAL units
        lay = sc.lattice()
        lay.set_vectors([2, 0, 0], [2, 2, 0], [0, 0, 3])
        lay.add_atom("Na", (0.5, 0.5, 0.5), unit=sc.Unit.Crystal)
        self.assertAtomsEqual(lay.atoms()[0], ("Na", (2, 1, 1.5)))
        self.assertAtomsEqual(lay.atoms(unit=sc.Unit.Crystal)[0],
                              ("Na", (0.5, 0.5, 0.5)))

    def test_add_atoms_bad(self) -> None:
        """
        Tests methods: add_atom, and add_atoms, where they should fail
        """
        lay = sc.lattice()

        # Adding atoms before changing elementary cell vectors:
        # (we don't know what to do with the atomic positions,
        # so we refuse the temptation to guess and raise an error)
        # Note: set_vectors should have a behaviour flag allowing
        # specifying what to do with the atomic positions
        lay.add_atom("Na", (0.5, 0.5, 0.5), unit=sc.Unit.Crystal)
        with self.assertRaises(UndefinedBehaviourError):
            lay.set_vectors([4, 0, 0], [4, 4, 0], [0, 0, 6])

        # Test bad type of values passed to function
        with self.assertRaises(TypeError):
            # Bad length of atomic position vector
            lay.add_atom("O", (0))
            lay.add_atom("O", (1, 2, 3, 4))

            # Bad number of arguments to add atom
            lay.add_atom("N")
            lay.add_atom("N", 0, 0)

            # Non-atom passed to add_atoms
            lay.add_atoms(["whatever"])

            # Non-unit passed as unit
            lay.add_atom("N", (0, 0), unit="meter")

    def test_save_POSCAR(self):
        os.system("mkdir -p tmp")
        fn = "tmp/test_POSCAR"
        lay = sc.lattice()
        lay.set_vectors([1, 2, 3], [0.5, 0.7, 0.91], [3, 1, 0])
        lay.add_atoms([
            ("Fe", (0, 2)),
            ("Zn", (1, 0.5, 3), (0, 1, -1)),
            ("Zn", (0.1, 0.2, 0.7)),
            ("Zn", (0, 0, 0))
        ])
        lay.add_atoms([
            ("Zn", (0.1, 0, 0), (0, 0, 1)),
            ("Zn", (0.2, 0, 0), (0, 0, -1)),
            ("Zn", (0.3, 0, 0), (0, 0, 1))
        ], unit=sc.Unit.Crystal)

        # first goes Fe (-21.84...)
        # then Zn, starting with z-spin=1 and in order of adding,
        # so: z-spin=1: (0.1, 0, 0), (0.3, 0, 0) etc.
        expected_poscar = """supercell_generated_POSCAR
1.0
1 2 3
0.5 0.7 0.91
3 1 0
1 3
Direct
-21.84 72 -4.72
0.1 0 0
0.3 0 0
2.66 -8 0.48
0 0 0
17.38 -54 3.54
0.2 0 0
"""

        lay.save_POSCAR(filename=fn)
        with open(fn, 'r') as f:
            poscar = f.read()
        os.system("rm -f " + fn)

        self.assertEqual(expected_poscar, poscar)

        # test stdout
        names = ["Fe", "Zn"]
        # https://stackoverflow.com/questions/4219717/how-to-assert-output-with-nosetest-unittest-in-python
        with patch('sys.stdout', new=StringIO()) as fakeOutput:
            lay.save_POSCAR()
            self.assertEqual(fakeOutput.getvalue(), expected_poscar + "\n" + \
                             "Note: The order of the atomic species in this generated POSCAR " + \
                             "file is as follows:\n" + " ".join(names) + "\n" + \
                             "MAGMOM flag: 0 2*1 2*0 2*-1\n")
            # TODO: test sorting by z-spin in atomic species

    def test_save_xsf(self):
        os.system("mkdir -p tmp")
        fn = "tmp/test.xsf"
        lay = sc.lattice()
        lay.set_vectors([1, 2, 3], [0.5, 0.7, 0.91], [3, 1, 0])
        lay.add_atoms([
            ("Fe", (0, 2)),
            ("Zn", (1, 0.5, 3), (0, 1, -1)),
            ("Zn", (0.1, 0.2, 0.7)),
            ("Zn", (0, 0, 0))
        ])

        expected_xsf = """CRYSTAL

PRIMVEC
1 2 3
0.5 0.7 0.91
3 1 0

PRIMCOORD
4 1
26 0 2 0 0 0 0
30 1 0.5 3 0 1 -1
30 0.1 0.2 0.7 0 0 0
30 0 0 0 0 0 0
"""

        lay.save_xsf(filename=fn)
        with open(fn, 'r') as f:
            xsf = f.read()
        os.system("rm -f " + fn)

        self.assertEqual(expected_xsf, xsf)

        # test stdout
        # https://stackoverflow.com/questions/4219717/how-to-assert-output-with-nosetest-unittest-in-python
        with patch('sys.stdout', new=StringIO()) as fakeOutput:
            lay.save_xsf()
            self.assertEqual(fakeOutput.getvalue(), expected_xsf)

    def test_vasp_TMP(self):
        # TODO: remove this "test"
        os.system("mkdir -p tmp")
        fn = "tmp/POSCAR"
        lay = sc.lattice()
        lay.set_vectors([25.56, -7.38, 0], [4.26, 14.76, 0], [0, 0, 18.5])
        atoms = [("Ni", (-0.604069, 11.560890, 12.646191), sc.Z_SPIN_UP), # 0
("Ni", (4.264502, 14.723747, 12.646191), sc.Z_SPIN_UP), # 1
("Ni", (9.133074, 17.886604, 12.646191), sc.Z_SPIN_UP), # 2
("Ni", (14.610217, 9.452319, 12.646191), sc.Z_SPIN_UP), # 3
("Ni", (14.001645, 21.049462, 12.646191), sc.Z_SPIN_UP), # 4
("Ni", (19.478788, 12.615176, 12.646191), sc.Z_SPIN_UP), # 5
("Ni", (24.347360, 15.778033, 12.646191), sc.Z_SPIN_UP), # 6
("Ni", (1.522614, 2.955881, 12.645779), sc.Z_SPIN_UP), # 7
("Ni", (6.391186, 6.118738, 12.645779), sc.Z_SPIN_UP), # 8
("Ni", (11.259757, 9.281595, 12.645779), sc.Z_SPIN_UP), # 9
("Ni", (16.736900, 0.847309, 12.645779), sc.Z_SPIN_UP), # 10
("Ni", (16.128329, 12.444452, 12.645779), sc.Z_SPIN_UP), # 11
("Ni", (21.605472, 4.010167, 12.645779), sc.Z_SPIN_UP), # 12
("Ni", (26.474043, 7.173024, 12.645779), sc.Z_SPIN_UP), # 13
("Ni", (-0.299797, 5.762309, 12.646101), sc.Z_SPIN_DOWN), # 14
("Ni", (4.568774, 8.925167, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (9.437345, 12.088024, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (14.914488, 3.653738, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (14.305917, 15.250881, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (19.783060, 6.816595, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (24.651631, 9.979452, 12.646101), sc.Z_SPIN_DOWN),
("Ni", (1.218343, 8.754461, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (6.086914, 11.917318, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (10.955486, 15.080175, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (16.432629, 6.645890, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (15.824057, 18.243032, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (21.301200, 9.808747, 12.645876), sc.Z_SPIN_DOWN),
("Ni", (26.169772, 12.971604, 12.645876), sc.Z_SPIN_DOWN),
("P", (3.044544, 5.940000, 13.734889)),
("P", (7.913115, 9.102857, 13.734889)),
("P", (12.781687, 12.265714, 13.734889)),
("P", (18.258830, 3.831428, 13.734889)),
("P", (17.650258, 15.428571, 13.734889)),
("P", (23.127401, 6.994286, 13.734889)),
("P", (27.995973, 10.157143, 13.734889)),
("P", (3.046276, 5.941136, 11.556974)),
("P", (7.914847, 9.103993, 11.556974)),
("P", (12.783419, 12.266850, 11.556974)),
("P", (18.260562, 3.832564, 11.556974)),
("P", (17.651990, 15.429707, 11.556974)),
("P", (23.129133, 6.995422, 11.556974)),
("P", (27.997704, 10.158279, 11.556974)),
("P", (-2.128305, 8.575721, 13.735007)),
("P", (2.740266, 11.738578, 13.735007)),
("P", (7.608838, 14.901435, 13.735007)),
("P", (13.085981, 6.467149, 13.735007)),
("P", (12.477409, 18.064292, 13.735007)),
("P", (17.954552, 9.630007, 13.735007)),
("P", (22.823124, 12.792864, 13.735007)),
("P", (-2.126572, 8.576855, 11.557093)),
("P", (2.741999, 11.739712, 11.557093)),
("P", (7.610570, 14.902569, 11.557093)),
("P", (13.087713, 6.468283, 11.557093)),
("P", (12.479142, 18.065426, 11.557093)),
("P", (17.956285, 9.631140, 11.557093)),
("P", (22.824856, 12.793997, 11.557093)),
("S", (1.390585, 4.865602, 11.080497)),
("S", (6.259156, 8.028460, 11.080497)),
("S", (11.127727, 11.191317, 11.080497)),
("S", (16.604870, 2.757031, 11.080497)),
("S", (15.996299, 14.354174, 11.080497)),
("S", (21.473442, 5.919888, 11.080497)),
("S", (26.342013, 9.082745, 11.080497)),
("S", (-1.925505, 4.751122, 11.083854)),
("S", (2.943067, 7.913979, 11.083854)),
("S", (7.811638, 11.076837, 11.083854)),
("S", (13.288781, 2.642551, 11.083854)),
("S", (12.680210, 14.239694, 11.083854)),
("S", (18.157353, 5.805408, 11.083854)),
("S", (23.025924, 8.968265, 11.083854)),
("S", (-0.062287, 1.881717, 11.083729)),
("S", (4.806284, 5.044574, 11.083729)),
("S", (9.674856, 8.207432, 11.083729)),
("S", (15.151998, -0.226854, 11.083729)),
("S", (14.543427, 11.370289, 11.083729)),
("S", (20.020570, 2.936003, 11.083729)),
("S", (24.889141, 6.098860, 11.083729)),
("S", (-0.168415, 3.852557, 14.211516)),
("S", (4.700156, 7.015414, 14.211516)),
("S", (9.568728, 10.178271, 14.211516)),
("S", (15.045870, 1.743985, 14.211516)),
("S", (14.437299, 13.341128, 14.211516)),
("S", (19.914442, 4.906842, 14.211516)),
("S", (24.783013, 8.069699, 14.211516)),
("S", (1.284405, 6.836459, 14.208087)),
("S", (6.152976, 9.999316, 14.208087)),
("S", (11.021548, 13.162173, 14.208087)),
("S", (16.498691, 4.727887, 14.208087)),
("S", (15.890119, 16.325030, 14.208087)),
("S", (21.367262, 7.890744, 14.208087)),
("S", (26.235834, 11.053601, 14.208087)),
("S", (3.147667, 3.967109, 14.207989)),
("S", (8.016239, 7.129966, 14.207989)),
("S", (12.884810, 10.292823, 14.207989)),
("S", (18.361953, 1.858537, 14.207989)),
("S", (17.753382, 13.455680, 14.207989)),
("S", (23.230525, 5.021394, 14.207989)),
("S", (28.099096, 8.184251, 14.207989)),
("S", (-3.782267, 7.501318, 11.080629)),
("S", (1.086305, 10.664175, 11.080629)),
("S", (5.954876, 13.827032, 11.080629)),
("S", (11.432019, 5.392747, 11.080629)),
("S", (10.823448, 16.989889, 11.080629)),
("S", (16.300590, 8.555604, 11.080629)),
("S", (21.169162, 11.718461, 11.080629)),
("S", (3.247386, 2.115397, 11.083921)),
("S", (8.115957, 5.278254, 11.083921)),
("S", (12.984528, 8.441111, 11.083921)),
("S", (18.461671, 0.006826, 11.083921)),
("S", (17.853100, 11.603968, 11.083921)),
("S", (23.330243, 3.169683, 11.083921)),
("S", (28.198814, 6.332540, 11.083921)),
("S", (-0.366567, 7.680321, 11.083803)),
("S", (4.502004, 10.843178, 11.083803)),
("S", (9.370576, 14.006035, 11.083803)),
("S", (14.847719, 5.571749, 11.083803)),
("S", (14.239147, 17.168892, 11.083803)),
("S", (19.716290, 8.734606, 11.083803)),
("S", (24.584862, 11.897464, 11.083803)),
("S", (-0.472697, 9.651133, 14.211648)),
("S", (4.395874, 12.813990, 14.211648)),
("S", (9.264446, 15.976847, 14.211648)),
("S", (14.741589, 7.542562, 14.211648)),
("S", (14.133017, 19.139704, 14.211648)),
("S", (19.610160, 10.705419, 14.211648)),
("S", (24.478732, 13.868276, 14.211648)),
("S", (1.588694, 1.037922, 14.208154)),
("S", (6.457266, 4.200779, 14.208154)),
("S", (11.325837, 7.363637, 14.208154)),
("S", (16.802980, -1.070649, 14.208154)),
("S", (16.194409, 10.526494, 14.208154)),
("S", (21.671552, 2.092208, 14.208154)),
("S", (26.540123, 5.255065, 14.208154)),
("S", (-2.025157, 6.602816, 14.208062)),
("S", (2.843414, 9.765673, 14.208062)),
("S", (7.711985, 12.928530, 14.208062)),
("S", (13.189128, 4.494244, 14.208062)),
("S", (12.580557, 16.091387, 14.208062)),
("S", (18.057700, 7.657101, 14.208062)),
("S", (22.926271, 10.819958, 14.208062)),
("C", (0.000000, 0.000000, 0.000000)),
("C", (2.130000, 1.230000, 0.000000)),
("C", (4.260000, -0.000000, 0.000000)),
("C", (6.390000, -1.230000, 0.000000)),
("C", (8.520000, -2.460000, 0.000000)),
("C", (4.260000, 2.460000, 0.000000)),
("C", (6.390000, 1.230000, 0.000000)),
("C", (2.130000, 3.690000, 0.000000)),
("C", (8.520000, -0.000000, 0.000000)),
("C", (10.650000, -1.230000, 0.000000)),
("C", (12.780000, -2.460000, 0.000000)),
("C", (14.910000, -3.690000, 0.000000)),
("C", (17.040000, -4.920000, 0.000000)),
("C", (6.390000, 3.690000, 0.000000)),
("C", (8.520000, 2.460000, 0.000000)),
("C", (4.260000, 4.920000, 0.000000)),
("C", (10.650000, 1.230000, 0.000000)),
("C", (2.130000, 6.150000, 0.000000)),
("C", (12.780000, -0.000000, 0.000000)),
("C", (14.910000, -1.230000, 0.000000)),
("C", (17.040000, -2.460000, 0.000000)),
("C", (19.170000, -3.690000, 0.000000)),
("C", (21.300000, -4.920000, 0.000000)),
("C", (23.430000, -6.150000, 0.000000)),
("C", (8.520000, 4.920000, 0.000000)),
("C", (10.650000, 3.690000, 0.000000)),
("C", (6.390000, 6.150000, 0.000000)),
("C", (12.780000, 2.460000, 0.000000)),
("C", (4.260000, 7.380000, 0.000000)),
("C", (14.910000, 1.230000, 0.000000)),
("C", (17.040000, -0.000000, 0.000000)),
("C", (19.170000, -1.230000, 0.000000)),
("C", (21.300000, -2.460000, 0.000000)),
("C", (23.430000, -3.690000, 0.000000)),
("C", (25.560000, -4.920000, 0.000000)),
("C", (10.650000, 6.150000, 0.000000)),
("C", (12.780000, 4.920000, 0.000000)),
("C", (8.520000, 7.380000, 0.000000)),
("C", (14.910000, 3.690000, 0.000000)),
("C", (6.390000, 8.610000, 0.000000)),
("C", (17.040000, 2.460000, 0.000000)),
("C", (4.260000, 9.840000, 0.000000)),
("C", (19.170000, 1.230000, 0.000000)),
("C", (21.300000, -0.000000, 0.000000)),
("C", (23.430000, -1.230000, 0.000000)),
("C", (25.560000, -2.460000, 0.000000)),
("C", (12.780000, 7.380000, 0.000000)),
("C", (14.910000, 6.150000, 0.000000)),
("C", (10.650000, 8.610000, 0.000000)),
("C", (17.040000, 4.920000, 0.000000)),
("C", (8.520000, 9.840000, 0.000000)),
("C", (19.170000, 3.690000, 0.000000)),
("C", (6.390000, 11.070000, 0.000000)),
("C", (21.300000, 2.460000, 0.000000)),
("C", (4.260000, 12.300000, 0.000000)),
("C", (23.430000, 1.230000, 0.000000)),
("C", (25.560000, -0.000000, 0.000000)),
("C", (14.910000, 8.610000, 0.000000)),
("C", (17.040000, 7.380000, 0.000000)),
("C", (12.780000, 9.840000, 0.000000)),
("C", (19.170000, 6.150000, 0.000000)),
("C", (10.650000, 11.070000, 0.000000)),
("C", (21.300000, 4.920000, 0.000000)),
("C", (8.520000, 12.300000, 0.000000)),
("C", (23.430000, 3.690000, 0.000000)),
("C", (6.390000, 13.530000, 0.000000)),
("C", (25.560000, 2.460000, 0.000000)),
("C", (27.690000, 1.230000, 0.000000)),
("C", (17.040000, 9.840000, 0.000000)),
("C", (19.170000, 8.610000, 0.000000)),
("C", (14.910000, 11.070000, 0.000000)),
("C", (21.300000, 7.380000, 0.000000)),
("C", (23.430000, 6.150000, 0.000000)),
("C", (25.560000, 4.920000, 0.000000)),
("C", (27.690000, 3.690000, 0.000000)),
("C", (23.430000, 8.610000, 0.000000)),
("C", (25.560000, 7.380000, 0.000000)),
("C", (27.690000, 6.150000, 0.000000)),
("C", (2.840000, -0.000000, 0.000000)),
("C", (4.970000, 1.230000, 0.000000)),
("C", (7.100000, -0.000000, 0.000000)),
("C", (9.230000, -1.230000, 0.000000)),
("C", (11.360000, -2.460000, 0.000000)),
("C", (7.100000, 2.460000, 0.000000)),
("C", (9.230000, 1.230000, 0.000000)),
("C", (4.970000, 3.690000, 0.000000)),
("C", (11.360000, -0.000000, 0.000000)),
("C", (13.490000, -1.230000, 0.000000)),
("C", (15.620000, -2.460000, 0.000000)),
("C", (17.750000, -3.690000, 0.000000)),
("C", (19.880000, -4.920000, 0.000000)),
("C", (9.230000, 3.690000, 0.000000)),
("C", (11.360000, 2.460000, 0.000000)),
("C", (7.100000, 4.920000, 0.000000)),
("C", (13.490000, 1.230000, 0.000000)),
("C", (4.970000, 6.150000, 0.000000)),
("C", (15.620000, -0.000000, 0.000000)),
("C", (17.750000, -1.230000, 0.000000)),
("C", (19.880000, -2.460000, 0.000000)),
("C", (22.010000, -3.690000, 0.000000)),
("C", (24.140000, -4.920000, 0.000000)),
("C", (26.270000, -6.150000, 0.000000)),
("C", (11.360000, 4.920000, 0.000000)),
("C", (13.490000, 3.690000, 0.000000)),
("C", (9.230000, 6.150000, 0.000000)),
("C", (15.620000, 2.460000, 0.000000)),
("C", (7.100000, 7.380000, 0.000000)),
("C", (17.750000, 1.230000, 0.000000)),
("C", (19.880000, -0.000000, 0.000000)),
("C", (22.010000, -1.230000, 0.000000)),
("C", (24.140000, -2.460000, 0.000000)),
("C", (26.270000, -3.690000, 0.000000)),
("C", (28.400000, -4.920000, 0.000000)),
("C", (13.490000, 6.150000, 0.000000)),
("C", (15.620000, 4.920000, 0.000000)),
("C", (11.360000, 7.380000, 0.000000)),
("C", (17.750000, 3.690000, 0.000000)),
("C", (9.230000, 8.610000, 0.000000)),
("C", (19.880000, 2.460000, 0.000000)),
("C", (7.100000, 9.840000, 0.000000)),
("C", (22.010000, 1.230000, 0.000000)),
("C", (24.140000, -0.000000, 0.000000)),
("C", (26.270000, -1.230000, 0.000000)),
("C", (28.400000, -2.460000, 0.000000)),
("C", (15.620000, 7.380000, 0.000000)),
("C", (17.750000, 6.150000, 0.000000)),
("C", (13.490000, 8.610000, 0.000000)),
("C", (19.880000, 4.920000, 0.000000)),
("C", (11.360000, 9.840000, 0.000000)),
("C", (22.010000, 3.690000, 0.000000)),
("C", (9.230000, 11.070000, 0.000000)),
("C", (24.140000, 2.460000, 0.000000)),
("C", (7.100000, 12.300000, 0.000000)),
("C", (26.270000, 1.230000, 0.000000)),
("C", (28.400000, -0.000000, 0.000000)),
("C", (17.750000, 8.610000, 0.000000)),
("C", (19.880000, 7.380000, 0.000000)),
("C", (15.620000, 9.840000, 0.000000)),
("C", (22.010000, 6.150000, 0.000000)),
("C", (13.490000, 11.070000, 0.000000)),
("C", (24.140000, 4.920000, 0.000000)),
("C", (11.360000, 12.300000, 0.000000)),
("C", (26.270000, 3.690000, 0.000000)),
("C", (9.230000, 13.530000, 0.000000)),
("C", (28.400000, 2.460000, 0.000000)),
("C", (30.530000, 1.230000, 0.000000)),
("C", (19.880000, 9.840000, 0.000000)),
("C", (22.010000, 8.610000, 0.000000)),
("C", (17.750000, 11.070000, 0.000000)),
("C", (24.140000, 7.380000, 0.000000)),
("C", (26.270000, 6.150000, 0.000000)),
("C", (28.400000, 4.920000, 0.000000)),
("C", (30.530000, 3.690000, 0.000000)),
("C", (26.270000, 8.610000, 0.000000)),
("C", (28.400000, 7.380000, 0.000000)),
("C", (30.530000, 6.150000, 0.000000))]
        min_z = 100000
        for a in atoms:
            if a[0] != "C" and a[1][2] < min_z:
                min_z = a[1][2]
        self.assertTrue(min_z > 2.5)
        offset = min_z - 2.5
        for i, a in enumerate(atoms):
            if a[0] != "C":
                try:
                    atoms[i] = (a[0], (a[1][0], a[1][1], a[1][2] - offset), a[2])
                except IndexError:
                    atoms[i] = (a[0], (a[1][0], a[1][1], a[1][2] - offset))

        lay.add_atoms(atoms, unit=sc.Unit.Angstrom)
        print(lay.atoms(unit=sc.Unit.Crystal))
        print("LENGTH: ", len(lay.atoms()))
        lay.save_POSCAR(fn)
        lay.save_xsf(fn+".xsf")